//
// ----------------------------- LN NODE INTERFACE + RELATED DEFINITIONS -----------------------------
//

interface LightningNode {
    [Throws=LnError]
    constructor(Config config, EventsCallback events_callback);

    [Throws=LnError]
    NodeInfo get_node_info();

    [Throws=LnError]
    LspFee query_lsp_fee();

    [Throws=LnError]
    PaymentAmountLimits get_payment_amount_limits();

    [Throws=LnError]
    CalculateLspFeeResponse calculate_lsp_fee(u64 amount_sat);

    [Throws=LnError]
    InvoiceDetails create_invoice(u64 amount_sat, OpeningFeeParams? lsp_fee_params, string description, string metadata);

    [Throws=DecodeDataError]
    DecodedData decode_data(string data);

    MaxRoutingFeeMode get_payment_max_routing_fee_mode(u64 amount_sat);

    [Throws=PayError]
    void pay_invoice(InvoiceDetails invoice_details, string metadata);

    [Throws=PayError]
    void pay_open_invoice(InvoiceDetails invoice_details, u64 amount_sat, string metadata);

    [Throws=LnError]
    string pay_lnurlp(u64 amount_sat, LnUrlPayRequestData lnurl_pay_request_data);

    [Throws=LnError]
    sequence<Payment> get_latest_payments(u32 number_of_payments);

    [Throws=LnError]
    Payment get_payment(string hash);

    void foreground();

    void background();

    sequence<string> list_currency_codes();

    ExchangeRate? get_exchange_rate();

    void change_fiat_currency(string fiat_currency);

    void change_timezone_config(TzConfig timezone_config);

    [Throws=LnError]
    void accept_pocket_terms_and_conditions();

    [Throws=LnError]
    FiatTopupInfo register_fiat_topup(string? email, string user_iban, string user_currency);

    [Throws=LnError]
    sequence<OfferInfo> query_uncompleted_offers();

    [Throws=LnError]
    string request_offer_collection(OfferInfo offer);

    [Throws=LnError]
    void register_notification_token(string notification_token, string language_iso_639_1, string country_iso_3166_1_alpha_2);

    string? get_wallet_pubkey_id();

    [Throws=LnError]
    string get_payment_uuid(string payment_hash);

    [Throws=LnError]
    u32 query_onchain_fee_rate();

    [Throws=LnError]
    string sweep(string address, u32 onchain_fee_rate);

    [Throws=LnError]
    SwapAddressInfo generate_swap_address(OpeningFeeParams? lsp_fee_params);

    [Throws=LnError]
    sequence<FailedSwapInfo> get_unresolved_failed_swaps();

    [Throws=LnError]
    string resolve_failed_swap(string failed_swap_address, string to_address, u32 onchain_fee_rate);

    [Throws=LnError]
    void hide_topup(string id);

    [Throws=LnError]
    void log_debug_info();
};

dictionary Config {
    EnvironmentCode environment;
    bytes seed;
    string fiat_currency;
    string local_persistence_path;
    TzConfig timezone_config;
    boolean enable_file_logging;
};

enum EnvironmentCode {
    "Local",
    "Dev",
    "Stage",
    "Prod",
};

enum Network {
    "Bitcoin",
    "Testnet",
    "Signet",
    "Regtest",
};

dictionary TzConfig {
    string timezone_id;
    i32 timezone_utc_offset_secs;
};

callback interface EventsCallback {
    void payment_received(string payment_hash);
    void payment_sent(string payment_hash, string payment_preimage);
    void payment_failed(string payment_hash);
    void channel_closed(string channel_id, string reason);
};

dictionary NodeInfo {
    string node_pubkey;
    sequence<string> peers;
    Amount onchain_balance;
    ChannelsInfo channels_info;
};

dictionary ChannelsInfo {
    Amount local_balance;
    Amount inbound_capacity;
    Amount outbound_capacity;
};

dictionary LspFee {
    Amount channel_minimum_fee;
    u64 channel_fee_permyriad;
};

dictionary PaymentAmountLimits {
    Amount max_receive;
    LiquidityLimit liquidity_limit;
};

dictionary OpeningFeeParams {
        u64 min_msat;
        u32 proportional;
        string valid_until;
        u32 max_idle_time;
        u32 max_client_to_self_delay;
        string promise;
};

dictionary CalculateLspFeeResponse {
    Amount lsp_fee;
    OpeningFeeParams? lsp_fee_params;
};

[Enum]
interface LiquidityLimit {
    None();
    MaxFreeReceive(Amount amount);
    MinReceive(Amount amount);
};

dictionary InvoiceDetails {
    string invoice;
    Amount? amount;
    string description;
    string payment_hash;
    string payee_pub_key;
    timestamp creation_timestamp;
    duration expiry_interval;
    timestamp expiry_timestamp;
};

[Enum]
interface DecodedData {
    Bolt11Invoice(InvoiceDetails invoice_details);
    LnUrlPay(LnUrlPayDetails lnurl_pay_details);
};

dictionary LnUrlPayDetails {
    Amount min_sendable;
    Amount max_sendable;
    LnUrlPayRequestData request_data;
};

dictionary LnUrlPayRequestData {
    string callback;
    u64 min_sendable;
    u64 max_sendable;
    string metadata_str;
    u16 comment_allowed;
    string domain;
    string? ln_address;
};

[Enum]
interface MaxRoutingFeeMode {
    Relative(u16 max_fee_permyriad);
    Absolute(Amount max_fee_amount);
};

dictionary Payment {
    PaymentType payment_type;
    PaymentState payment_state;
    PayErrorCode? fail_reason;
    string hash;
    Amount amount;
    InvoiceDetails invoice_details;
    TzTime created_at;
    string description;
    string? preimage;
    Amount? network_fees;
    Amount? lsp_fees;
    OfferKind? offer;
    string metadata;
};

enum PaymentType {
    "Receiving",
    "Sending",
};

enum PaymentState {
    "Created",
    "Succeeded",
    "Failed",
    "Retried",
    "InvoiceExpired",
};

dictionary TzTime {
    timestamp time;
    string timezone_id;
    i32 timezone_utc_offset_secs;
};

dictionary FiatValue {
    u64 minor_units;
    string currency_code;
    u32 rate;
    timestamp converted_at;
};

dictionary ExchangeRate {
    string currency_code;
    u32 rate;
    timestamp updated_at;
};

dictionary Amount {
    u64 sats;
    FiatValue? fiat;
};

dictionary FiatTopupInfo {
    string order_id;
    string debitor_iban;
    string creditor_reference;
    string creditor_iban;
    string creditor_bank_name;
    string creditor_bank_street;
    string creditor_bank_postal_code;
    string creditor_bank_town;
    string creditor_bank_country;
    string creditor_bank_bic;
    string creditor_name;
    string creditor_street;
    string creditor_postal_code;
    string creditor_town;
    string creditor_country;
};

dictionary OfferInfo {
    OfferKind offer_kind;
    Amount amount;
    string? lnurlw;
    timestamp created_at;
    timestamp? expires_at;
    OfferStatus status;
};

enum PermanentFailureCode {
    "ThresholdExceeded",
    "OrderInactive",
    "CompaniesUnsupported",
    "CountryUnsupported",
    "OtherRiskDetected",
    "CustomerRequested",
    "AccountNotMatching",
    "PayoutExpired",
};

[Enum]
interface TemporaryFailureCode {
    NoRoute();
    InvoiceExpired();
    Unexpected();
    Unknown(
        string msg
    );
};

[Enum]
interface PocketOfferError {
    TemporaryFailure(
        TemporaryFailureCode code
    );
    PermanentFailure(
        PermanentFailureCode code
    );
};

[Enum]
interface OfferKind {
    Pocket(
        string id,
        ExchangeRate exchange_rate,
        u64 topup_value_minor_units,
        u64 exchange_fee_minor_units,
        u16 exchange_fee_rate_permyriad,
        PocketOfferError? error
    );
};

enum OfferStatus {
    "READY",
    "FAILED",
    "REFUNDED",
    "SETTLED",
};

dictionary SwapAddressInfo {
    string address;
    Amount min_deposit;
    Amount max_deposit;
};

dictionary FailedSwapInfo {
    string address;
    Amount amount;
    timestamp created_at;
};

//
// ----------------------------- TOP LEVEL FUNCTIONS + RELATED DEFINITIONS -----------------------------
//

namespace lipalightninglib {
    [Throws=SimpleError]
    Secret generate_secret(string passphrase);

    [Throws=MnemonicError]
    Secret mnemonic_to_secret(sequence<string> mnemonic_string, string passphrase);

    sequence<string> words_by_prefix(string prefix);

    [Throws=LnError]
    void accept_terms_and_conditions(EnvironmentCode environment, bytes seed);

    [Throws=LnError]
    void recover_lightning_node(EnvironmentCode environment, bytes seed, string local_persistence_path, boolean enable_file_logging);
};

dictionary Secret {
    sequence<string> mnemonic;
    string passphrase;
    bytes seed;
};

//
// ----------------------------- ERROR RELATED DEFINITIONS -----------------------------
//

[Error]
interface SimpleError {
    Simple(string msg);
};

[Error]
interface MnemonicError {
    BadWordCount(u64 count);
    UnknownWord(u64 index);
    BadEntropyBitCount();
    InvalidChecksum();
    AmbiguousLanguages();
};

[Error]
interface LnError {
    InvalidInput(string msg);
    RuntimeError(RuntimeErrorCode code, string msg);
    PermanentFailure(string msg);
};

enum RuntimeErrorCode {
    "AuthServiceUnavailable",
    "OfferServiceUnavailable",
    "LspServiceUnavailable",
    "NodeUnavailable",
    "FailedFundMigration",
};

[Error]
interface PayError {
    InvalidInput(string msg);
    RuntimeError(PayErrorCode code, string msg);
    PermanentFailure(string msg);
};

enum PayErrorCode {
    "InvoiceExpired",
    "AlreadyUsedInvoice",
    "PayingToSelf",
    "NoRouteFound",
    "RecipientRejected",
    "RetriesExhausted",
    "NoMoreRoutes",
    "UnexpectedError",
};

enum UnsupportedDataType {
    "BitcoinAddress",
    "LnUrlAuth",
    "LnUrlWithdraw",
    "NodeId",
    "Url",
};

[Error]
interface DecodeDataError {
    LnUrlError(string msg);
    Unsupported(UnsupportedDataType typ);
    Unrecognized(string msg);
};
