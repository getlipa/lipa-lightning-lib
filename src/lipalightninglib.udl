enum Network {
    "Bitcoin",
    "Testnet",
    "Signet",
    "Regtest",
};

dictionary Config {
    Network network;
    sequence<u8> seed;
    string esplora_api_url;
    NodeAddress lsp_node;
    string rgs_url;
};

dictionary NodeAddress {
    string pub_key;
    string address;
};

callback interface RedundantStorageCallback {
    boolean object_exists(string bucket, string key);
    sequence<u8> get_object(string bucket, string key);
    boolean check_health(string bucket);
    boolean put_object(string bucket, string key, sequence<u8> value);
    sequence<string> list_objects(string bucket);
    boolean delete_object(string bucket, string key);
};

[Error]
enum CallbackError {
    // Invalid input.
    // Consider fixing the input and retrying the request.
    "InvalidInput",

    // Recoverable problem (e.g. network issue, problem with en external service).
    // Consider retrying the request.
    "RuntimeError",

    // Unrecoverable problem (e.g. internal invariant broken).
    // Consider suggesting the user to report the issue to the developers.
    "PermanentFailure",

    // This value is required by UniFFI library. Do not use the value directly.
    "UnexpectedUniFFI",
};

// Remote key-value storage. Buckets are not managed explicitly.
callback interface RemoteStorageCallback {
    // Check if the remote server is reachable and the client has necessary
    // permissions. The library will likely call this method before starting
    // a transaction.
    // Hint: request and cache an access token if needed.
    boolean check_health();

    // List objects in the bucket. Return empty list if there is no such bucket.
    [Throws=CallbackError]
    sequence<string> list_objects(string bucket);

    // Check if the bucket exists and if the object is in the bucket.
    [Throws=CallbackError]
    boolean object_exists(string bucket, string key);

    [Throws=CallbackError]
    sequence<u8> get_object(string bucket, string key);

    // Atomically put the object in the bucket (create the bucket if it does not
    // exists).
    // Must only return after being certain that data was persisted safely.
    // Failure to do so for `monitors` bucket may result in loss of funds.
    // Returning `false` for `monitors` bucket will likely result in a channel
    // being force-closed.
    [Throws=CallbackError]
    void put_object(string bucket, string key, sequence<u8> value);

    [Throws=CallbackError]
    void delete_object(string bucket, string key);
};

[Error]
enum InitializationError {
    "AsyncRuntime",
    "ChainMonitorWatchChannel",
    "ChainSync",
    "ChannelMonitorBackup",
    "EsploraClient",
    "KeysManager",
    "Logic",
    "PeerConnection",
    "PublicKey",
    "SecretGeneration",
};

[Error]
enum RuntimeError {
    "ChainSync",
    "InvalidAddress",
    "InvalidPubKey",
    "Logic",
    "PeerConnection",
};

[Error]
enum LipaError {
    "InvalidInput",
    "RuntimeError",
    "PermanentFailure",
};

interface LightningNode {
    [Throws=InitializationError]
    constructor([ByRef] Config config, RedundantStorageCallback redundant_storage_callback, LspCallback lsp_callback);

    NodeInfo get_node_info();

    [Throws=LipaError]
    LspFee query_lsp_fee();

    boolean connected_to_node([ByRef] NodeAddress node);

    [Throws=LipaError]
    string create_invoice(u64 amount_msat, string description);

    [Throws=LipaError]
    void sync_graph();
};

dictionary ChannelsInfo {
    u16 num_channels;
    u16 num_usable_channels;
    u64 local_balance_msat;

    // Capacity the node can actually receive.
    // It excludes non usable channels, pending htlcs, channels reserves, etc.
    u64 inbound_capacity_msat;

    // Capacity the node can actually send.
    // It excludes non usable channels, pending htlcs, channels reserves, etc.
    u64 outbound_capacity_msat;
};

dictionary NodeInfo {
    sequence<u8> node_pubkey;
    u16 num_peers;
    ChannelsInfo channels_info;
};

dictionary LspFee {
  u64 min_msat;
  // 1_000_000 is 100%
  u64 rate_ppm;
};

[Error]
enum LspError {
    "Grpc",
    "Network",
    "UnexpectedUniFFI",
};

callback interface LspCallback {
    [Throws=LspError]
    sequence<u8> channel_information();
    [Throws=LspError]
    void register_payment(sequence<u8> bytes);
};

enum LogLevel {
    "Error",
    "Warn",
    "Info",
    "Debug",
    "Trace",
};

dictionary Secret {
    sequence<string> mnemonic;
    string passphrase;
    sequence<u8> seed;
};

namespace lipalightninglib {
    void init_native_logger_once(LogLevel min_level);

    [Throws=LipaError]
    Secret generate_secret(string passphrase);

    [Throws=LipaError]
    Secret mnemonic_to_secret(sequence<string> mnemonic_string, string passphrase);
};
