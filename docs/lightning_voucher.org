#+title: ðŸŽŸï¸ Lightning Voucher

* Background
Sending to a phone number is a great feature, but what if the recipient is not registered with lipa?
Wouldn't it be great if we could /text or email satoshis/ instead, allowing the recipient
to withdraw the satoshis using any Lightning wallet?
** ðŸ“– Story
You had lunch with your friend and he paid for you.
After you return home, you want to pay him back.
You open your lipa wallet and realize that you do not know his Lightning address,
but you have his phone number.
You try to send to his phone number, but the wallet says that the phone number
is not registered and suggests you text him a *voucher* that can be redeemed by any Lightning wallet.
Your friend receives a message with the voucher from you;
it is basically an LNURL-withdraw, so he withdraws to his Lightning wallet.
You get a notification on your phone that the voucher was redeemed.
** â™Š Existing Solutions
- River Link (https://river.com/river-link) offers something very similar,
  but you have to have a River account to issue such vouchers (anyone can redeem).
  And of course, River is a custodial service.
- https://tipcards.io allows issuing similar vouchers, but it is also a custodial service.
  Additionally, if no one redeems your voucher, you have to track it yourself.
- Ecash based solutions, but it will required ecash (not lightning-native).

* Lightning Voucher
I propose a *non-custodial* trust-minimized scheme which can be implemented today.
Alternatively, an almost *trustless* scheme could be achieved with some changes to the LNURL-withdraw standard.
Vouchers are issued by lipa wallet users and registered on the lipa server.
A voucher would look like =https://lipa.swiss/w?lightning=lnurl12344...=.
When someone tries to redeem such a voucher, the lipa server sends a notification to the user's phone.
The user's wallet then checks the voucher and sends satoshis to the redeemer.
** TODO Update the steps
** ðŸªœ Steps
1. the issuer generates a voucher as a pair of private/public keys: =issuer_key=, =redeemer_key=
2. the issuer encrypts the voucher metadata with =redeemer_key= (using symmetric cryptography)
3. the issuer registers the encrypted voucher on the lipa server by =hash= (as a hash of =redeemer_key=)
4. the issuer sends the voucher with =redeemer_key= to the recipient (redeemer) off-band
5. the redeemer requests the lipa server with the =redeemer_key= to resolve the voucher
6. the lipa server computes =hash=, finds voucher metadata, decrypts it, and returns it to the redeemer
7. the redeemer issues an *invoice*, (optinally encrypts it with =redeemer_key= for =issuer_key=), sends to the lipa server
8. the lipa server forwards the voucher and the *invoice* to the issuer (by sending a notification)
9. the issuer (decrypts the *invoice*), checks that the voucher was indeed issued by him and was not redeemed yet
10. the issuer pays the *invoice*
*** Passcode
A =passcode= is a secret piece of information sent along with the voucher to the redeemer.
The redeemer *encypts* their invoice with the =passcode= (as =encrypt(passcode + invoice)=)
and sends it to the lipa server (without revealing the =passcode= itself).
The issuer then decrypts the encrypted invoice.
** ðŸ” Security Model
The scheme is *non-custodial*; no one holds custody of the funds.\\
The web server can manipulate some metadata about vouchers,
such as the amount range, as long as it stays within the valid range
(otherwise, the issuer validation will fail).
Such a manipulation can be detected by the redeemer by checking the =signature=.
*** Without Passcode
The web server *can steal funds* by replacing the invoice sent by the redeemer
(similar to the Lightning Address problem). Malicious intent is required for this to happen.
The risk is somewhat minimized by limiting the timeframe when such an attack is possible
to the moment of voucher resolution (step 4).
Therefore, if a voucher is never redeemed, it cannot be stolen.
*** With Passcode
The scheme is almost *trustless* (/even with a weak passcode!/):
the web server can only deny voucher registration or redemption.
** ðŸ™ˆ Privacy
- redeemer of a voucher does not learn anything about the issuer
- web server knows issuer of a voucher, number of vouchers
- web server learns associated amounts, expiration date, redeemer ip addres *only* at the redemption
  (redeemer's invoice if the redeemer does not encrypt it)
** ðŸš§ Limitations
- redemption fails if the issuer is offline
- vouchers are single-use only
- implementing the *passcode* feature requires some changes to the LUD:
  - trivial logic on the web server
  - moderate logic on the issuer's side
  - moderate logic on the redeemer's side
** âž• Additional Features
- if a voucher is never redeemed, the issuer retains satoshis
- the issuer can set an expiration date for the voucher
- the issuer can recall a previously issued voucher
- the issuer is notified upon voucher redemption
- a voucher can have an amount range (a form of tipping)
- a voucher can be safely retried to be redeemed if the previous attempt failed
- safe to post online or offline in a public space
- transparent encryption upgrade (if the redeemer is capable)
** ðŸ’¼ Usecases
- send bitcoin as /a kind of/ a bearer asset (the example from the story)
- a gift
- print on phisical vochers for promotion
** ðŸ‘ Benefits
- during voucher resolution, we can promote lipa wallet (since it is a web page)
  (also stating that it is more private and secure to redeem the voucher with lipa wallet)
- plays nicely with *send to phone number feature*
- surpasses *referral program*
- lightning-native no need for ecash

* Sequence Diagram
#+ATTR_HTML: :alt Sequence diagram
[[./diagram.png]]
#+begin_src plantuml :file diagram.png
@startuml
actor Issuer as issuer
participant "Lipa Web Server" as server
actor Redeemer as redeemer

== Voucher issuance ==

activate issuer
issuer -> issuer: generate secret **issuer_key**,\ncompute public key **redeemer_key**
issuer -> issuer: sign voucher with **issuer_key** to **signature**
issuer -> issuer: encrypt voucher data with **redeemer_key** to **data**\n(as with a symmetric key)
issuer -> issuer: compute **hash** of **redeemer_key**
issuer -> server ++: **hash**, **data**
return **lnurl_prefix**

issuer --> redeemer: server URL with **redeemer_key**\ni.e. https://lipa.swiss/w?lightning=<redeemer_key>

opt With passcode
    issuer -> issuer: generate **passcode** and associate with **redeemer_key**
    issuer --> redeemer: **passcode**
end
deactivate issuer	

== Voucher redemption ==

redeemer -> server ++: resolve URL with **redeemer_key**
activate redeemer
server -> server: hash **redeemer_key**, find voucher
server -> server: decrypt **data** with **redeemer_key**, check **signature**
return amount_range, expiration_date, **signature**

opt Encryption-aware redeemer
    redeemer -> redeemer: check **signature**
end
redeemer -> redeemer: issue **invoice**
opt Encryption-aware redeemer
    alt Without passcode
        redeemer -> redeemer: encrypt **invoice**\nwith **redeemer_key** for **issuer_key**
    else With passcode
        redeemer -> redeemer: encrypt (**passcode** + **invoice**)\nwith **redeemer_key** for **issuer_key**
    end
end

redeemer -> server ++: **redeemer_key**, **invoice**
server -> issuer ++: **redeemer_key**, **invoice**
issuer -> issuer: find local voucher by **redeemer_key**
issuer -> issuer: decrypt and validate **invoice**
issuer -> server: ok
server -> redeemer --: ok				
deactivate redeemer

issuer --> redeemer --: pay **invoice**
@enduml
#+end_src

